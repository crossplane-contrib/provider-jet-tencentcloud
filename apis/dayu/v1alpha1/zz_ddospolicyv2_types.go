// SPDX-FileCopyrightText: 2023 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AclsInitParameters struct {

	// Block action, take the value [drop, trans].
	// Action, optional values: drop, transmit, forward.
	Action *string `json:"action,omitempty" tf:"action,omitempty"`

	// The end destination port, take the value 1~65535, which must be greater than or equal to the starting destination port.
	// The destination port ends, and the value range is 0~65535.
	DPortEnd *float64 `json:"dPortEnd,omitempty" tf:"d_port_end,omitempty"`

	// From the destination port, take the value 0~65535.
	// The destination port starts, and the value range is 0~65535.
	DPortStart *float64 `json:"dPortStart,omitempty" tf:"d_port_start,omitempty"`

	// Protocol type, desirable values tcp, udp, all.
	// Protocol type, desirable values tcp, udp, all.
	ForwardProtocol *string `json:"forwardProtocol,omitempty" tf:"forward_protocol,omitempty"`

	// Policy priority, the lower the number, the higher the level, the higher the rule matches, taking a value of 1-1000.Note: This field may return null, indicating that a valid value could not be retrieved.
	// Policy priority, the lower the number, the higher the level, the higher the rule matches, taking a value of 1-1000.Note: This field may return null, indicating that a valid value could not be retrieved.
	Priority *float64 `json:"priority,omitempty" tf:"priority,omitempty"`

	// The source port ends, and the acceptable value ranges from 0 to 65535.
	// The source port ends, and the acceptable value ranges from 0 to 65535.
	SPortEnd *float64 `json:"sPortEnd,omitempty" tf:"s_port_end,omitempty"`

	// The source port starts, and the value range is 0~65535.
	// The source port starts, and the value range is 0~65535.
	SPortStart *float64 `json:"sPortStart,omitempty" tf:"s_port_start,omitempty"`
}

type AclsObservation struct {

	// Block action, take the value [drop, trans].
	// Action, optional values: drop, transmit, forward.
	Action *string `json:"action,omitempty" tf:"action,omitempty"`

	// The end destination port, take the value 1~65535, which must be greater than or equal to the starting destination port.
	// The destination port ends, and the value range is 0~65535.
	DPortEnd *float64 `json:"dPortEnd,omitempty" tf:"d_port_end,omitempty"`

	// From the destination port, take the value 0~65535.
	// The destination port starts, and the value range is 0~65535.
	DPortStart *float64 `json:"dPortStart,omitempty" tf:"d_port_start,omitempty"`

	// Protocol type, desirable values tcp, udp, all.
	// Protocol type, desirable values tcp, udp, all.
	ForwardProtocol *string `json:"forwardProtocol,omitempty" tf:"forward_protocol,omitempty"`

	// Policy priority, the lower the number, the higher the level, the higher the rule matches, taking a value of 1-1000.Note: This field may return null, indicating that a valid value could not be retrieved.
	// Policy priority, the lower the number, the higher the level, the higher the rule matches, taking a value of 1-1000.Note: This field may return null, indicating that a valid value could not be retrieved.
	Priority *float64 `json:"priority,omitempty" tf:"priority,omitempty"`

	// The source port ends, and the acceptable value ranges from 0 to 65535.
	// The source port ends, and the acceptable value ranges from 0 to 65535.
	SPortEnd *float64 `json:"sPortEnd,omitempty" tf:"s_port_end,omitempty"`

	// The source port starts, and the value range is 0~65535.
	// The source port starts, and the value range is 0~65535.
	SPortStart *float64 `json:"sPortStart,omitempty" tf:"s_port_start,omitempty"`
}

type AclsParameters struct {

	// Block action, take the value [drop, trans].
	// Action, optional values: drop, transmit, forward.
	// +kubebuilder:validation:Optional
	Action *string `json:"action" tf:"action,omitempty"`

	// The end destination port, take the value 1~65535, which must be greater than or equal to the starting destination port.
	// The destination port ends, and the value range is 0~65535.
	// +kubebuilder:validation:Optional
	DPortEnd *float64 `json:"dPortEnd" tf:"d_port_end,omitempty"`

	// From the destination port, take the value 0~65535.
	// The destination port starts, and the value range is 0~65535.
	// +kubebuilder:validation:Optional
	DPortStart *float64 `json:"dPortStart" tf:"d_port_start,omitempty"`

	// Protocol type, desirable values tcp, udp, all.
	// Protocol type, desirable values tcp, udp, all.
	// +kubebuilder:validation:Optional
	ForwardProtocol *string `json:"forwardProtocol" tf:"forward_protocol,omitempty"`

	// Policy priority, the lower the number, the higher the level, the higher the rule matches, taking a value of 1-1000.Note: This field may return null, indicating that a valid value could not be retrieved.
	// Policy priority, the lower the number, the higher the level, the higher the rule matches, taking a value of 1-1000.Note: This field may return null, indicating that a valid value could not be retrieved.
	// +kubebuilder:validation:Optional
	Priority *float64 `json:"priority" tf:"priority,omitempty"`

	// The source port ends, and the acceptable value ranges from 0 to 65535.
	// The source port ends, and the acceptable value ranges from 0 to 65535.
	// +kubebuilder:validation:Optional
	SPortEnd *float64 `json:"sPortEnd" tf:"s_port_end,omitempty"`

	// The source port starts, and the value range is 0~65535.
	// The source port starts, and the value range is 0~65535.
	// +kubebuilder:validation:Optional
	SPortStart *float64 `json:"sPortStart" tf:"s_port_start,omitempty"`
}

type BlackWhiteIpsInitParameters struct {

	// Ip of resource instance.
	// Ip of resource instance.
	IP *string `json:"ip,omitempty" tf:"ip,omitempty"`

	// IP type, value [black(blacklist IP), white (whitelist IP)].
	// IP type, value [`black`(blacklist IP), `white` (whitelist IP)].
	IPType *string `json:"ipType,omitempty" tf:"ip_type,omitempty"`
}

type BlackWhiteIpsObservation struct {

	// Ip of resource instance.
	// Ip of resource instance.
	IP *string `json:"ip,omitempty" tf:"ip,omitempty"`

	// IP type, value [black(blacklist IP), white (whitelist IP)].
	// IP type, value [`black`(blacklist IP), `white` (whitelist IP)].
	IPType *string `json:"ipType,omitempty" tf:"ip_type,omitempty"`
}

type BlackWhiteIpsParameters struct {

	// Ip of resource instance.
	// Ip of resource instance.
	// +kubebuilder:validation:Optional
	IP *string `json:"ip" tf:"ip,omitempty"`

	// IP type, value [black(blacklist IP), white (whitelist IP)].
	// IP type, value [`black`(blacklist IP), `white` (whitelist IP)].
	// +kubebuilder:validation:Optional
	IPType *string `json:"ipType" tf:"ip_type,omitempty"`
}

type DdosConnectLimitInitParameters struct {

	// Based on connection suppression trigger threshold, value range [0,4294967295].
	// Based on connection suppression trigger threshold, value range [0,4294967295].
	BadConnThreshold *float64 `json:"badConnThreshold,omitempty" tf:"bad_conn_threshold,omitempty"`

	// Abnormal connection detection condition, connection timeout, value range [0,65535].
	// Abnormal connection detection condition, connection timeout, value range [0,65535].
	ConnTimeout *float64 `json:"connTimeout,omitempty" tf:"conn_timeout,omitempty"`

	// Concurrent connection control based on destination IP+ destination port.
	// Concurrent connection control based on destination IP+ destination port.
	DstConnLimit *float64 `json:"dstConnLimit,omitempty" tf:"dst_conn_limit,omitempty"`

	// Limit on the number of news per second based on the destination IP.
	// Limit on the number of news per second based on the destination IP.
	DstNewLimit *float64 `json:"dstNewLimit,omitempty" tf:"dst_new_limit,omitempty"`

	// Abnormal connection detection conditions, empty connection guard switch, value range[0,1].
	// Abnormal connection detection conditions, empty connection guard switch, value range[0,1].
	NullConnEnable *float64 `json:"nullConnEnable,omitempty" tf:"null_conn_enable,omitempty"`

	// Concurrent connection control based on source IP + destination IP.
	// Concurrent connection control based on source IP + destination IP.
	SdConnLimit *float64 `json:"sdConnLimit,omitempty" tf:"sd_conn_limit,omitempty"`

	// The limit on the number of news per second based on source IP + destination IP.
	// The limit on the number of news per second based on source IP + destination IP.
	SdNewLimit *float64 `json:"sdNewLimit,omitempty" tf:"sd_new_limit,omitempty"`

	// Anomaly connection detection condition, syn threshold, value range [0,100].
	// Anomaly connection detection condition, syn threshold, value range [0,100].
	SynLimit *float64 `json:"synLimit,omitempty" tf:"syn_limit,omitempty"`

	// Anomalous connection detection condition, percentage of syn ack, value range [0,100].
	// Anomalous connection detection condition, percentage of syn ack, value range [0,100].
	SynRate *float64 `json:"synRate,omitempty" tf:"syn_rate,omitempty"`
}

type DdosConnectLimitObservation struct {

	// Based on connection suppression trigger threshold, value range [0,4294967295].
	// Based on connection suppression trigger threshold, value range [0,4294967295].
	BadConnThreshold *float64 `json:"badConnThreshold,omitempty" tf:"bad_conn_threshold,omitempty"`

	// Abnormal connection detection condition, connection timeout, value range [0,65535].
	// Abnormal connection detection condition, connection timeout, value range [0,65535].
	ConnTimeout *float64 `json:"connTimeout,omitempty" tf:"conn_timeout,omitempty"`

	// Concurrent connection control based on destination IP+ destination port.
	// Concurrent connection control based on destination IP+ destination port.
	DstConnLimit *float64 `json:"dstConnLimit,omitempty" tf:"dst_conn_limit,omitempty"`

	// Limit on the number of news per second based on the destination IP.
	// Limit on the number of news per second based on the destination IP.
	DstNewLimit *float64 `json:"dstNewLimit,omitempty" tf:"dst_new_limit,omitempty"`

	// Abnormal connection detection conditions, empty connection guard switch, value range[0,1].
	// Abnormal connection detection conditions, empty connection guard switch, value range[0,1].
	NullConnEnable *float64 `json:"nullConnEnable,omitempty" tf:"null_conn_enable,omitempty"`

	// Concurrent connection control based on source IP + destination IP.
	// Concurrent connection control based on source IP + destination IP.
	SdConnLimit *float64 `json:"sdConnLimit,omitempty" tf:"sd_conn_limit,omitempty"`

	// The limit on the number of news per second based on source IP + destination IP.
	// The limit on the number of news per second based on source IP + destination IP.
	SdNewLimit *float64 `json:"sdNewLimit,omitempty" tf:"sd_new_limit,omitempty"`

	// Anomaly connection detection condition, syn threshold, value range [0,100].
	// Anomaly connection detection condition, syn threshold, value range [0,100].
	SynLimit *float64 `json:"synLimit,omitempty" tf:"syn_limit,omitempty"`

	// Anomalous connection detection condition, percentage of syn ack, value range [0,100].
	// Anomalous connection detection condition, percentage of syn ack, value range [0,100].
	SynRate *float64 `json:"synRate,omitempty" tf:"syn_rate,omitempty"`
}

type DdosConnectLimitParameters struct {

	// Based on connection suppression trigger threshold, value range [0,4294967295].
	// Based on connection suppression trigger threshold, value range [0,4294967295].
	// +kubebuilder:validation:Optional
	BadConnThreshold *float64 `json:"badConnThreshold" tf:"bad_conn_threshold,omitempty"`

	// Abnormal connection detection condition, connection timeout, value range [0,65535].
	// Abnormal connection detection condition, connection timeout, value range [0,65535].
	// +kubebuilder:validation:Optional
	ConnTimeout *float64 `json:"connTimeout" tf:"conn_timeout,omitempty"`

	// Concurrent connection control based on destination IP+ destination port.
	// Concurrent connection control based on destination IP+ destination port.
	// +kubebuilder:validation:Optional
	DstConnLimit *float64 `json:"dstConnLimit" tf:"dst_conn_limit,omitempty"`

	// Limit on the number of news per second based on the destination IP.
	// Limit on the number of news per second based on the destination IP.
	// +kubebuilder:validation:Optional
	DstNewLimit *float64 `json:"dstNewLimit" tf:"dst_new_limit,omitempty"`

	// Abnormal connection detection conditions, empty connection guard switch, value range[0,1].
	// Abnormal connection detection conditions, empty connection guard switch, value range[0,1].
	// +kubebuilder:validation:Optional
	NullConnEnable *float64 `json:"nullConnEnable" tf:"null_conn_enable,omitempty"`

	// Concurrent connection control based on source IP + destination IP.
	// Concurrent connection control based on source IP + destination IP.
	// +kubebuilder:validation:Optional
	SdConnLimit *float64 `json:"sdConnLimit" tf:"sd_conn_limit,omitempty"`

	// The limit on the number of news per second based on source IP + destination IP.
	// The limit on the number of news per second based on source IP + destination IP.
	// +kubebuilder:validation:Optional
	SdNewLimit *float64 `json:"sdNewLimit" tf:"sd_new_limit,omitempty"`

	// Anomaly connection detection condition, syn threshold, value range [0,100].
	// Anomaly connection detection condition, syn threshold, value range [0,100].
	// +kubebuilder:validation:Optional
	SynLimit *float64 `json:"synLimit" tf:"syn_limit,omitempty"`

	// Anomalous connection detection condition, percentage of syn ack, value range [0,100].
	// Anomalous connection detection condition, percentage of syn ack, value range [0,100].
	// +kubebuilder:validation:Optional
	SynRate *float64 `json:"synRate" tf:"syn_rate,omitempty"`
}

type DdosGeoIPBlockConfigInitParameters struct {

	// Block action, take the value [drop, trans].
	// Block action, take the value [`drop`, `trans`].
	Action *string `json:"action,omitempty" tf:"action,omitempty"`

	// When the RegionType is customized, the AreaList must be filled in, and a maximum of 128 must be filled in.
	// When the RegionType is customized, the AreaList must be filled in, and a maximum of 128 must be filled in.
	AreaList []*float64 `json:"areaList,omitempty" tf:"area_list,omitempty"`

	// Zone type, value [oversea (overseas),china (domestic),customized (custom region)].
	// Zone type, value [oversea (overseas),china (domestic),customized (custom region)].
	RegionType *string `json:"regionType,omitempty" tf:"region_type,omitempty"`
}

type DdosGeoIPBlockConfigObservation struct {

	// Block action, take the value [drop, trans].
	// Block action, take the value [`drop`, `trans`].
	Action *string `json:"action,omitempty" tf:"action,omitempty"`

	// When the RegionType is customized, the AreaList must be filled in, and a maximum of 128 must be filled in.
	// When the RegionType is customized, the AreaList must be filled in, and a maximum of 128 must be filled in.
	AreaList []*float64 `json:"areaList,omitempty" tf:"area_list,omitempty"`

	// Zone type, value [oversea (overseas),china (domestic),customized (custom region)].
	// Zone type, value [oversea (overseas),china (domestic),customized (custom region)].
	RegionType *string `json:"regionType,omitempty" tf:"region_type,omitempty"`
}

type DdosGeoIPBlockConfigParameters struct {

	// Block action, take the value [drop, trans].
	// Block action, take the value [`drop`, `trans`].
	// +kubebuilder:validation:Optional
	Action *string `json:"action" tf:"action,omitempty"`

	// When the RegionType is customized, the AreaList must be filled in, and a maximum of 128 must be filled in.
	// When the RegionType is customized, the AreaList must be filled in, and a maximum of 128 must be filled in.
	// +kubebuilder:validation:Optional
	AreaList []*float64 `json:"areaList" tf:"area_list,omitempty"`

	// Zone type, value [oversea (overseas),china (domestic),customized (custom region)].
	// Zone type, value [oversea (overseas),china (domestic),customized (custom region)].
	// +kubebuilder:validation:Optional
	RegionType *string `json:"regionType" tf:"region_type,omitempty"`
}

type DdosPolicyV2InitParameters struct {

	// Port ACL policy for DDoS protection.
	// Port ACL policy for DDoS protection.
	Acls []AclsInitParameters `json:"acls,omitempty" tf:"acls,omitempty"`

	// DDoS-protected IP blacklist and whitelist.
	// DDoS-protected IP blacklist and whitelist.
	BlackWhiteIps []BlackWhiteIpsInitParameters `json:"blackWhiteIps,omitempty" tf:"black_white_ips,omitempty"`

	// Business of resource instance. bgpip indicates anti-anti-ip ip; bgp means exclusive package; bgp-multip means shared packet; net indicates anti-anti-ip pro version.
	// Business of resource instance. bgpip indicates anti-anti-ip ip; bgp means exclusive package; bgp-multip means shared packet; net indicates anti-anti-ip pro version.
	Business *string `json:"business,omitempty" tf:"business,omitempty"`

	// AI protection switch, take the value [on, off].
	// AI protection switch, take the value [`on`, `off`].
	DdosAI *string `json:"ddosAi,omitempty" tf:"ddos_ai,omitempty"`

	// DDoS connection suppression options.
	// DDoS connection suppression options.
	DdosConnectLimit []DdosConnectLimitInitParameters `json:"ddosConnectLimit,omitempty" tf:"ddos_connect_limit,omitempty"`

	// DDoS-protected area block configuration.
	// DDoS-protected area block configuration.
	DdosGeoIPBlockConfig []DdosGeoIPBlockConfigInitParameters `json:"ddosGeoIpBlockConfig,omitempty" tf:"ddos_geo_ip_block_config,omitempty"`

	// Protection class, value [low, middle, high].
	// Protection class, value [`low`, `middle`, `high`].
	DdosLevel *string `json:"ddosLevel,omitempty" tf:"ddos_level,omitempty"`

	// Access speed limit configuration for DDoS protection.
	// Access speed limit configuration for DDoS protection.
	DdosSpeedLimitConfig []DdosSpeedLimitConfigInitParameters `json:"ddosSpeedLimitConfig,omitempty" tf:"ddos_speed_limit_config,omitempty"`

	// DDoS cleaning threshold, value[0, 60, 80, 100, 150, 200, 250, 300, 400, 500, 700, 1000]; When the value is set to 0, it means that the default value is adopted.
	// DDoS cleaning threshold, value[0, 60, 80, 100, 150, 200, 250, 300, 400, 500, 700, 1000]; When the value is set to 0, it means that the default value is adopted.
	DdosThreshold *float64 `json:"ddosThreshold,omitempty" tf:"ddos_threshold,omitempty"`

	// Feature filtering rules for DDoS protection.
	// Feature filtering rules for DDoS protection.
	PacketFilters []DdosPolicyV2PacketFiltersInitParameters `json:"packetFilters,omitempty" tf:"packet_filters,omitempty"`

	// Protocol block configuration for DDoS protection.
	// Protocol block configuration for DDoS protection.
	ProtocolBlockConfig []ProtocolBlockConfigInitParameters `json:"protocolBlockConfig,omitempty" tf:"protocol_block_config,omitempty"`

	// The ID of the resource instance.
	// The ID of the resource instance.
	ResourceID *string `json:"resourceId,omitempty" tf:"resource_id,omitempty"`

	// Water print config.
	// Water print config.
	WaterPrintConfig []WaterPrintConfigInitParameters `json:"waterPrintConfig,omitempty" tf:"water_print_config,omitempty"`
}

type DdosPolicyV2Observation struct {

	// Port ACL policy for DDoS protection.
	// Port ACL policy for DDoS protection.
	Acls []AclsObservation `json:"acls,omitempty" tf:"acls,omitempty"`

	// DDoS-protected IP blacklist and whitelist.
	// DDoS-protected IP blacklist and whitelist.
	BlackWhiteIps []BlackWhiteIpsObservation `json:"blackWhiteIps,omitempty" tf:"black_white_ips,omitempty"`

	// Business of resource instance. bgpip indicates anti-anti-ip ip; bgp means exclusive package; bgp-multip means shared packet; net indicates anti-anti-ip pro version.
	// Business of resource instance. bgpip indicates anti-anti-ip ip; bgp means exclusive package; bgp-multip means shared packet; net indicates anti-anti-ip pro version.
	Business *string `json:"business,omitempty" tf:"business,omitempty"`

	// AI protection switch, take the value [on, off].
	// AI protection switch, take the value [`on`, `off`].
	DdosAI *string `json:"ddosAi,omitempty" tf:"ddos_ai,omitempty"`

	// DDoS connection suppression options.
	// DDoS connection suppression options.
	DdosConnectLimit []DdosConnectLimitObservation `json:"ddosConnectLimit,omitempty" tf:"ddos_connect_limit,omitempty"`

	// DDoS-protected area block configuration.
	// DDoS-protected area block configuration.
	DdosGeoIPBlockConfig []DdosGeoIPBlockConfigObservation `json:"ddosGeoIpBlockConfig,omitempty" tf:"ddos_geo_ip_block_config,omitempty"`

	// Protection class, value [low, middle, high].
	// Protection class, value [`low`, `middle`, `high`].
	DdosLevel *string `json:"ddosLevel,omitempty" tf:"ddos_level,omitempty"`

	// Access speed limit configuration for DDoS protection.
	// Access speed limit configuration for DDoS protection.
	DdosSpeedLimitConfig []DdosSpeedLimitConfigObservation `json:"ddosSpeedLimitConfig,omitempty" tf:"ddos_speed_limit_config,omitempty"`

	// DDoS cleaning threshold, value[0, 60, 80, 100, 150, 200, 250, 300, 400, 500, 700, 1000]; When the value is set to 0, it means that the default value is adopted.
	// DDoS cleaning threshold, value[0, 60, 80, 100, 150, 200, 250, 300, 400, 500, 700, 1000]; When the value is set to 0, it means that the default value is adopted.
	DdosThreshold *float64 `json:"ddosThreshold,omitempty" tf:"ddos_threshold,omitempty"`

	// ID of the resource.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// Feature filtering rules for DDoS protection.
	// Feature filtering rules for DDoS protection.
	PacketFilters []DdosPolicyV2PacketFiltersObservation `json:"packetFilters,omitempty" tf:"packet_filters,omitempty"`

	// Protocol block configuration for DDoS protection.
	// Protocol block configuration for DDoS protection.
	ProtocolBlockConfig []ProtocolBlockConfigObservation `json:"protocolBlockConfig,omitempty" tf:"protocol_block_config,omitempty"`

	// The ID of the resource instance.
	// The ID of the resource instance.
	ResourceID *string `json:"resourceId,omitempty" tf:"resource_id,omitempty"`

	// Water print config.
	// Water print config.
	WaterPrintConfig []WaterPrintConfigObservation `json:"waterPrintConfig,omitempty" tf:"water_print_config,omitempty"`
}

type DdosPolicyV2PacketFiltersInitParameters struct {

	// Block action, take the value [drop, trans].
	// Action, take the value [drop,transmit,drop_black (discard and black out),drop_rst (Interception),drop_black_rst (intercept and block),forward].
	Action *string `json:"action,omitempty" tf:"action,omitempty"`

	// The end destination port, take the value 1~65535, which must be greater than or equal to the starting destination port.
	// The end destination port, take the value 1~65535, which must be greater than or equal to the starting destination port.
	DPortEnd *float64 `json:"dPortEnd,omitempty" tf:"d_port_end,omitempty"`

	// From the destination port, take the value 0~65535.
	// From the destination port, take the value 0~65535.
	DPortStart *float64 `json:"dPortStart,omitempty" tf:"d_port_start,omitempty"`

	// Detection depth from the detection position, value [0,1500].
	// Detection depth from the detection position, value [0,1500].
	Depth *float64 `json:"depth,omitempty" tf:"depth,omitempty"`

	// Second detection depth starting from the second detection position, value [0,1500].
	// Second detection depth starting from the second detection position, value [0,1500].
	Depth2 *float64 `json:"depth2,omitempty" tf:"depth2,omitempty"`

	// Whether to include the detected value, take the value [0 (included),1 (not included)].
	// Whether to include the detected value, take the value [0 (included),1 (not included)].
	IsNot *float64 `json:"isNot,omitempty" tf:"is_not,omitempty"`

	// Whether the second detection contains the detected value, the value [0 (included),1 (not included)].
	// Whether the second detection contains the detected value, the value [0 (included),1 (not included)].
	IsNot2 *float64 `json:"isNot2,omitempty" tf:"is_not2,omitempty"`

	// Detect position, take the value [begin_l3 (IP header),begin_l4 (TCP/UDP header),begin_l5 (T load), no_match (mismatch)].
	// Detect position, take the value [begin_l3 (IP header),begin_l4 (TCP/UDP header),begin_l5 (T load), no_match (mismatch)].
	MatchBegin *string `json:"matchBegin,omitempty" tf:"match_begin,omitempty"`

	// The second detection position. take the value [begin_l3 (IP header),begin_l4 (TCP/UDP header),begin_l5 (T load), no_match (mismatch)].
	// The second detection position. take the value [begin_l3 (IP header),begin_l4 (TCP/UDP header),begin_l5 (T load), no_match (mismatch)].
	MatchBegin2 *string `json:"matchBegin2,omitempty" tf:"match_begin2,omitempty"`

	// When there is a second detection condition, the and/or relationship with the first detection condition, takes the value [And (and relationship),none (fill in this value when there is no second detection condition)].
	// When there is a second detection condition, the and/or relationship with the first detection condition, takes the value [And (and relationship),none (fill in this value when there is no second detection condition)].
	MatchLogic *string `json:"matchLogic,omitempty" tf:"match_logic,omitempty"`

	// Detection type, value [sunday (keyword),pcre (regular expression)].
	// Detection type, value [sunday (keyword),pcre (regular expression)].
	MatchType *string `json:"matchType,omitempty" tf:"match_type,omitempty"`

	// The second type of detection, takes the value [sunday (keyword),pcre (regular expression)].
	// The second type of detection, takes the value [sunday (keyword),pcre (regular expression)].
	MatchType2 *string `json:"matchType2,omitempty" tf:"match_type2,omitempty"`

	// Watermark offset, value range: [0-100].
	// Offset from detection position, value range [0, Depth].
	Offset *float64 `json:"offset,omitempty" tf:"offset,omitempty"`

	// Offset from the second detection position, value range [0,Depth2].
	// Offset from the second detection position, value range [0,Depth2].
	Offset2 *float64 `json:"offset2,omitempty" tf:"offset2,omitempty"`

	// The maximum message length, taken from 1 to 1500, must be greater than or equal to the minimum message length.
	// The maximum message length, taken from 1 to 1500, must be greater than or equal to the minimum message length.
	PktlenMax *float64 `json:"pktlenMax,omitempty" tf:"pktlen_max,omitempty"`

	// Minimum message length, 1-1500.
	// Minimum message length, 1-1500.
	PktlenMin *float64 `json:"pktlenMin,omitempty" tf:"pktlen_min,omitempty"`

	// Protocol, value [tcp udp icmp all].
	// Protocol, value [tcp udp icmp all].
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	// The source port ends, and the acceptable value ranges from 0 to 65535.
	// End source port, take the value 1~65535, must be greater than or equal to the starting source port.
	SPortEnd *float64 `json:"sPortEnd,omitempty" tf:"s_port_end,omitempty"`

	// The source port starts, and the value range is 0~65535.
	// Start the source port, take the value 0~65535.
	SPortStart *float64 `json:"sPortStart,omitempty" tf:"s_port_start,omitempty"`

	// Detect values, key strings or regular expressions, take the value [When the detection type is sunday, please fill in the string or hexadecimal bytecode, for example 13233 corresponds to the hexadecimal bytecode of the string 123;When the detection type is pcre, please fill in the regular expression string;].
	// Detect values, key strings or regular expressions, take the value [When the detection type is sunday, please fill in the string or hexadecimal bytecode, for example 13233 corresponds to the hexadecimal bytecode of the string `123`;When the detection type is pcre, please fill in the regular expression string;].
	Str *string `json:"str,omitempty" tf:"str,omitempty"`

	// The second detection value, the key string or regular expression, takes the value [When the detection type is sunday, please fill in the string or hexadecimal bytecode, for example 13233 corresponds to the hexadecimal bytecode of the string 123;When the detection type is pcre, please fill in the regular expression string;].
	// The second detection value, the key string or regular expression, takes the value [When the detection type is sunday, please fill in the string or hexadecimal bytecode, for example 13233 corresponds to the hexadecimal bytecode of the string `123`;When the detection type is pcre, please fill in the regular expression string;].
	Str2 *string `json:"str2,omitempty" tf:"str2,omitempty"`
}

type DdosPolicyV2PacketFiltersObservation struct {

	// Block action, take the value [drop, trans].
	// Action, take the value [drop,transmit,drop_black (discard and black out),drop_rst (Interception),drop_black_rst (intercept and block),forward].
	Action *string `json:"action,omitempty" tf:"action,omitempty"`

	// The end destination port, take the value 1~65535, which must be greater than or equal to the starting destination port.
	// The end destination port, take the value 1~65535, which must be greater than or equal to the starting destination port.
	DPortEnd *float64 `json:"dPortEnd,omitempty" tf:"d_port_end,omitempty"`

	// From the destination port, take the value 0~65535.
	// From the destination port, take the value 0~65535.
	DPortStart *float64 `json:"dPortStart,omitempty" tf:"d_port_start,omitempty"`

	// Detection depth from the detection position, value [0,1500].
	// Detection depth from the detection position, value [0,1500].
	Depth *float64 `json:"depth,omitempty" tf:"depth,omitempty"`

	// Second detection depth starting from the second detection position, value [0,1500].
	// Second detection depth starting from the second detection position, value [0,1500].
	Depth2 *float64 `json:"depth2,omitempty" tf:"depth2,omitempty"`

	// Whether to include the detected value, take the value [0 (included),1 (not included)].
	// Whether to include the detected value, take the value [0 (included),1 (not included)].
	IsNot *float64 `json:"isNot,omitempty" tf:"is_not,omitempty"`

	// Whether the second detection contains the detected value, the value [0 (included),1 (not included)].
	// Whether the second detection contains the detected value, the value [0 (included),1 (not included)].
	IsNot2 *float64 `json:"isNot2,omitempty" tf:"is_not2,omitempty"`

	// Detect position, take the value [begin_l3 (IP header),begin_l4 (TCP/UDP header),begin_l5 (T load), no_match (mismatch)].
	// Detect position, take the value [begin_l3 (IP header),begin_l4 (TCP/UDP header),begin_l5 (T load), no_match (mismatch)].
	MatchBegin *string `json:"matchBegin,omitempty" tf:"match_begin,omitempty"`

	// The second detection position. take the value [begin_l3 (IP header),begin_l4 (TCP/UDP header),begin_l5 (T load), no_match (mismatch)].
	// The second detection position. take the value [begin_l3 (IP header),begin_l4 (TCP/UDP header),begin_l5 (T load), no_match (mismatch)].
	MatchBegin2 *string `json:"matchBegin2,omitempty" tf:"match_begin2,omitempty"`

	// When there is a second detection condition, the and/or relationship with the first detection condition, takes the value [And (and relationship),none (fill in this value when there is no second detection condition)].
	// When there is a second detection condition, the and/or relationship with the first detection condition, takes the value [And (and relationship),none (fill in this value when there is no second detection condition)].
	MatchLogic *string `json:"matchLogic,omitempty" tf:"match_logic,omitempty"`

	// Detection type, value [sunday (keyword),pcre (regular expression)].
	// Detection type, value [sunday (keyword),pcre (regular expression)].
	MatchType *string `json:"matchType,omitempty" tf:"match_type,omitempty"`

	// The second type of detection, takes the value [sunday (keyword),pcre (regular expression)].
	// The second type of detection, takes the value [sunday (keyword),pcre (regular expression)].
	MatchType2 *string `json:"matchType2,omitempty" tf:"match_type2,omitempty"`

	// Watermark offset, value range: [0-100].
	// Offset from detection position, value range [0, Depth].
	Offset *float64 `json:"offset,omitempty" tf:"offset,omitempty"`

	// Offset from the second detection position, value range [0,Depth2].
	// Offset from the second detection position, value range [0,Depth2].
	Offset2 *float64 `json:"offset2,omitempty" tf:"offset2,omitempty"`

	// The maximum message length, taken from 1 to 1500, must be greater than or equal to the minimum message length.
	// The maximum message length, taken from 1 to 1500, must be greater than or equal to the minimum message length.
	PktlenMax *float64 `json:"pktlenMax,omitempty" tf:"pktlen_max,omitempty"`

	// Minimum message length, 1-1500.
	// Minimum message length, 1-1500.
	PktlenMin *float64 `json:"pktlenMin,omitempty" tf:"pktlen_min,omitempty"`

	// Protocol, value [tcp udp icmp all].
	// Protocol, value [tcp udp icmp all].
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	// The source port ends, and the acceptable value ranges from 0 to 65535.
	// End source port, take the value 1~65535, must be greater than or equal to the starting source port.
	SPortEnd *float64 `json:"sPortEnd,omitempty" tf:"s_port_end,omitempty"`

	// The source port starts, and the value range is 0~65535.
	// Start the source port, take the value 0~65535.
	SPortStart *float64 `json:"sPortStart,omitempty" tf:"s_port_start,omitempty"`

	// Detect values, key strings or regular expressions, take the value [When the detection type is sunday, please fill in the string or hexadecimal bytecode, for example 13233 corresponds to the hexadecimal bytecode of the string 123;When the detection type is pcre, please fill in the regular expression string;].
	// Detect values, key strings or regular expressions, take the value [When the detection type is sunday, please fill in the string or hexadecimal bytecode, for example 13233 corresponds to the hexadecimal bytecode of the string `123`;When the detection type is pcre, please fill in the regular expression string;].
	Str *string `json:"str,omitempty" tf:"str,omitempty"`

	// The second detection value, the key string or regular expression, takes the value [When the detection type is sunday, please fill in the string or hexadecimal bytecode, for example 13233 corresponds to the hexadecimal bytecode of the string 123;When the detection type is pcre, please fill in the regular expression string;].
	// The second detection value, the key string or regular expression, takes the value [When the detection type is sunday, please fill in the string or hexadecimal bytecode, for example 13233 corresponds to the hexadecimal bytecode of the string `123`;When the detection type is pcre, please fill in the regular expression string;].
	Str2 *string `json:"str2,omitempty" tf:"str2,omitempty"`
}

type DdosPolicyV2PacketFiltersParameters struct {

	// Block action, take the value [drop, trans].
	// Action, take the value [drop,transmit,drop_black (discard and black out),drop_rst (Interception),drop_black_rst (intercept and block),forward].
	// +kubebuilder:validation:Optional
	Action *string `json:"action" tf:"action,omitempty"`

	// The end destination port, take the value 1~65535, which must be greater than or equal to the starting destination port.
	// The end destination port, take the value 1~65535, which must be greater than or equal to the starting destination port.
	// +kubebuilder:validation:Optional
	DPortEnd *float64 `json:"dPortEnd" tf:"d_port_end,omitempty"`

	// From the destination port, take the value 0~65535.
	// From the destination port, take the value 0~65535.
	// +kubebuilder:validation:Optional
	DPortStart *float64 `json:"dPortStart" tf:"d_port_start,omitempty"`

	// Detection depth from the detection position, value [0,1500].
	// Detection depth from the detection position, value [0,1500].
	// +kubebuilder:validation:Optional
	Depth *float64 `json:"depth" tf:"depth,omitempty"`

	// Second detection depth starting from the second detection position, value [0,1500].
	// Second detection depth starting from the second detection position, value [0,1500].
	// +kubebuilder:validation:Optional
	Depth2 *float64 `json:"depth2" tf:"depth2,omitempty"`

	// Whether to include the detected value, take the value [0 (included),1 (not included)].
	// Whether to include the detected value, take the value [0 (included),1 (not included)].
	// +kubebuilder:validation:Optional
	IsNot *float64 `json:"isNot" tf:"is_not,omitempty"`

	// Whether the second detection contains the detected value, the value [0 (included),1 (not included)].
	// Whether the second detection contains the detected value, the value [0 (included),1 (not included)].
	// +kubebuilder:validation:Optional
	IsNot2 *float64 `json:"isNot2" tf:"is_not2,omitempty"`

	// Detect position, take the value [begin_l3 (IP header),begin_l4 (TCP/UDP header),begin_l5 (T load), no_match (mismatch)].
	// Detect position, take the value [begin_l3 (IP header),begin_l4 (TCP/UDP header),begin_l5 (T load), no_match (mismatch)].
	// +kubebuilder:validation:Optional
	MatchBegin *string `json:"matchBegin" tf:"match_begin,omitempty"`

	// The second detection position. take the value [begin_l3 (IP header),begin_l4 (TCP/UDP header),begin_l5 (T load), no_match (mismatch)].
	// The second detection position. take the value [begin_l3 (IP header),begin_l4 (TCP/UDP header),begin_l5 (T load), no_match (mismatch)].
	// +kubebuilder:validation:Optional
	MatchBegin2 *string `json:"matchBegin2" tf:"match_begin2,omitempty"`

	// When there is a second detection condition, the and/or relationship with the first detection condition, takes the value [And (and relationship),none (fill in this value when there is no second detection condition)].
	// When there is a second detection condition, the and/or relationship with the first detection condition, takes the value [And (and relationship),none (fill in this value when there is no second detection condition)].
	// +kubebuilder:validation:Optional
	MatchLogic *string `json:"matchLogic" tf:"match_logic,omitempty"`

	// Detection type, value [sunday (keyword),pcre (regular expression)].
	// Detection type, value [sunday (keyword),pcre (regular expression)].
	// +kubebuilder:validation:Optional
	MatchType *string `json:"matchType" tf:"match_type,omitempty"`

	// The second type of detection, takes the value [sunday (keyword),pcre (regular expression)].
	// The second type of detection, takes the value [sunday (keyword),pcre (regular expression)].
	// +kubebuilder:validation:Optional
	MatchType2 *string `json:"matchType2" tf:"match_type2,omitempty"`

	// Watermark offset, value range: [0-100].
	// Offset from detection position, value range [0, Depth].
	// +kubebuilder:validation:Optional
	Offset *float64 `json:"offset" tf:"offset,omitempty"`

	// Offset from the second detection position, value range [0,Depth2].
	// Offset from the second detection position, value range [0,Depth2].
	// +kubebuilder:validation:Optional
	Offset2 *float64 `json:"offset2" tf:"offset2,omitempty"`

	// The maximum message length, taken from 1 to 1500, must be greater than or equal to the minimum message length.
	// The maximum message length, taken from 1 to 1500, must be greater than or equal to the minimum message length.
	// +kubebuilder:validation:Optional
	PktlenMax *float64 `json:"pktlenMax" tf:"pktlen_max,omitempty"`

	// Minimum message length, 1-1500.
	// Minimum message length, 1-1500.
	// +kubebuilder:validation:Optional
	PktlenMin *float64 `json:"pktlenMin" tf:"pktlen_min,omitempty"`

	// Protocol, value [tcp udp icmp all].
	// Protocol, value [tcp udp icmp all].
	// +kubebuilder:validation:Optional
	Protocol *string `json:"protocol" tf:"protocol,omitempty"`

	// The source port ends, and the acceptable value ranges from 0 to 65535.
	// End source port, take the value 1~65535, must be greater than or equal to the starting source port.
	// +kubebuilder:validation:Optional
	SPortEnd *float64 `json:"sPortEnd" tf:"s_port_end,omitempty"`

	// The source port starts, and the value range is 0~65535.
	// Start the source port, take the value 0~65535.
	// +kubebuilder:validation:Optional
	SPortStart *float64 `json:"sPortStart" tf:"s_port_start,omitempty"`

	// Detect values, key strings or regular expressions, take the value [When the detection type is sunday, please fill in the string or hexadecimal bytecode, for example 13233 corresponds to the hexadecimal bytecode of the string 123;When the detection type is pcre, please fill in the regular expression string;].
	// Detect values, key strings or regular expressions, take the value [When the detection type is sunday, please fill in the string or hexadecimal bytecode, for example 13233 corresponds to the hexadecimal bytecode of the string `123`;When the detection type is pcre, please fill in the regular expression string;].
	// +kubebuilder:validation:Optional
	Str *string `json:"str" tf:"str,omitempty"`

	// The second detection value, the key string or regular expression, takes the value [When the detection type is sunday, please fill in the string or hexadecimal bytecode, for example 13233 corresponds to the hexadecimal bytecode of the string 123;When the detection type is pcre, please fill in the regular expression string;].
	// The second detection value, the key string or regular expression, takes the value [When the detection type is sunday, please fill in the string or hexadecimal bytecode, for example 13233 corresponds to the hexadecimal bytecode of the string `123`;When the detection type is pcre, please fill in the regular expression string;].
	// +kubebuilder:validation:Optional
	Str2 *string `json:"str2" tf:"str2,omitempty"`
}

type DdosPolicyV2Parameters struct {

	// Port ACL policy for DDoS protection.
	// Port ACL policy for DDoS protection.
	// +kubebuilder:validation:Optional
	Acls []AclsParameters `json:"acls,omitempty" tf:"acls,omitempty"`

	// DDoS-protected IP blacklist and whitelist.
	// DDoS-protected IP blacklist and whitelist.
	// +kubebuilder:validation:Optional
	BlackWhiteIps []BlackWhiteIpsParameters `json:"blackWhiteIps,omitempty" tf:"black_white_ips,omitempty"`

	// Business of resource instance. bgpip indicates anti-anti-ip ip; bgp means exclusive package; bgp-multip means shared packet; net indicates anti-anti-ip pro version.
	// Business of resource instance. bgpip indicates anti-anti-ip ip; bgp means exclusive package; bgp-multip means shared packet; net indicates anti-anti-ip pro version.
	// +kubebuilder:validation:Optional
	Business *string `json:"business,omitempty" tf:"business,omitempty"`

	// AI protection switch, take the value [on, off].
	// AI protection switch, take the value [`on`, `off`].
	// +kubebuilder:validation:Optional
	DdosAI *string `json:"ddosAi,omitempty" tf:"ddos_ai,omitempty"`

	// DDoS connection suppression options.
	// DDoS connection suppression options.
	// +kubebuilder:validation:Optional
	DdosConnectLimit []DdosConnectLimitParameters `json:"ddosConnectLimit,omitempty" tf:"ddos_connect_limit,omitempty"`

	// DDoS-protected area block configuration.
	// DDoS-protected area block configuration.
	// +kubebuilder:validation:Optional
	DdosGeoIPBlockConfig []DdosGeoIPBlockConfigParameters `json:"ddosGeoIpBlockConfig,omitempty" tf:"ddos_geo_ip_block_config,omitempty"`

	// Protection class, value [low, middle, high].
	// Protection class, value [`low`, `middle`, `high`].
	// +kubebuilder:validation:Optional
	DdosLevel *string `json:"ddosLevel,omitempty" tf:"ddos_level,omitempty"`

	// Access speed limit configuration for DDoS protection.
	// Access speed limit configuration for DDoS protection.
	// +kubebuilder:validation:Optional
	DdosSpeedLimitConfig []DdosSpeedLimitConfigParameters `json:"ddosSpeedLimitConfig,omitempty" tf:"ddos_speed_limit_config,omitempty"`

	// DDoS cleaning threshold, value[0, 60, 80, 100, 150, 200, 250, 300, 400, 500, 700, 1000]; When the value is set to 0, it means that the default value is adopted.
	// DDoS cleaning threshold, value[0, 60, 80, 100, 150, 200, 250, 300, 400, 500, 700, 1000]; When the value is set to 0, it means that the default value is adopted.
	// +kubebuilder:validation:Optional
	DdosThreshold *float64 `json:"ddosThreshold,omitempty" tf:"ddos_threshold,omitempty"`

	// Feature filtering rules for DDoS protection.
	// Feature filtering rules for DDoS protection.
	// +kubebuilder:validation:Optional
	PacketFilters []DdosPolicyV2PacketFiltersParameters `json:"packetFilters,omitempty" tf:"packet_filters,omitempty"`

	// Protocol block configuration for DDoS protection.
	// Protocol block configuration for DDoS protection.
	// +kubebuilder:validation:Optional
	ProtocolBlockConfig []ProtocolBlockConfigParameters `json:"protocolBlockConfig,omitempty" tf:"protocol_block_config,omitempty"`

	// The ID of the resource instance.
	// The ID of the resource instance.
	// +kubebuilder:validation:Optional
	ResourceID *string `json:"resourceId,omitempty" tf:"resource_id,omitempty"`

	// Water print config.
	// Water print config.
	// +kubebuilder:validation:Optional
	WaterPrintConfig []WaterPrintConfigParameters `json:"waterPrintConfig,omitempty" tf:"water_print_config,omitempty"`
}

type DdosSpeedLimitConfigInitParameters struct {

	// Bandwidth bps.
	// Bandwidth bps.
	Bandwidth *float64 `json:"bandwidth,omitempty" tf:"bandwidth,omitempty"`

	// List of port ranges, up to 8, multiple; Separated, the range is represented with -; this port range must be filled in; fill in the style 1:0-65535, style 2:80; 443; 1000-2000.
	// List of port ranges, up to 8, multiple; Separated, the range is represented with -; this port range must be filled in; fill in the style 1:0-65535, style 2:80; 443; 1000-2000.
	DstPortList *string `json:"dstPortList,omitempty" tf:"dst_port_list,omitempty"`

	// Speed limit mode, take the value [1 (speed limit based on source IP),2 (speed limit based on destination port)].
	// Speed limit mode, take the value [1 (speed limit based on source IP),2 (speed limit based on destination port)].
	Mode *float64 `json:"mode,omitempty" tf:"mode,omitempty"`

	// Packet rate pps.
	// Packet rate pps.
	PacketRate *float64 `json:"packetRate,omitempty" tf:"packet_rate,omitempty"`

	// IP protocol numbers, take the value[ ALL (all protocols),TCP (tcp protocol),UDP (udp protocol),SMP (smp protocol),1; 2-100 (custom protocol number range, up to 8)].
	// IP protocol numbers, take the value[ ALL (all protocols),TCP (tcp protocol),UDP (udp protocol),SMP (smp protocol),1; 2-100 (custom protocol number range, up to 8)].
	ProtocolList *string `json:"protocolList,omitempty" tf:"protocol_list,omitempty"`
}

type DdosSpeedLimitConfigObservation struct {

	// Bandwidth bps.
	// Bandwidth bps.
	Bandwidth *float64 `json:"bandwidth,omitempty" tf:"bandwidth,omitempty"`

	// List of port ranges, up to 8, multiple; Separated, the range is represented with -; this port range must be filled in; fill in the style 1:0-65535, style 2:80; 443; 1000-2000.
	// List of port ranges, up to 8, multiple; Separated, the range is represented with -; this port range must be filled in; fill in the style 1:0-65535, style 2:80; 443; 1000-2000.
	DstPortList *string `json:"dstPortList,omitempty" tf:"dst_port_list,omitempty"`

	// Speed limit mode, take the value [1 (speed limit based on source IP),2 (speed limit based on destination port)].
	// Speed limit mode, take the value [1 (speed limit based on source IP),2 (speed limit based on destination port)].
	Mode *float64 `json:"mode,omitempty" tf:"mode,omitempty"`

	// Packet rate pps.
	// Packet rate pps.
	PacketRate *float64 `json:"packetRate,omitempty" tf:"packet_rate,omitempty"`

	// IP protocol numbers, take the value[ ALL (all protocols),TCP (tcp protocol),UDP (udp protocol),SMP (smp protocol),1; 2-100 (custom protocol number range, up to 8)].
	// IP protocol numbers, take the value[ ALL (all protocols),TCP (tcp protocol),UDP (udp protocol),SMP (smp protocol),1; 2-100 (custom protocol number range, up to 8)].
	ProtocolList *string `json:"protocolList,omitempty" tf:"protocol_list,omitempty"`
}

type DdosSpeedLimitConfigParameters struct {

	// Bandwidth bps.
	// Bandwidth bps.
	// +kubebuilder:validation:Optional
	Bandwidth *float64 `json:"bandwidth" tf:"bandwidth,omitempty"`

	// List of port ranges, up to 8, multiple; Separated, the range is represented with -; this port range must be filled in; fill in the style 1:0-65535, style 2:80; 443; 1000-2000.
	// List of port ranges, up to 8, multiple; Separated, the range is represented with -; this port range must be filled in; fill in the style 1:0-65535, style 2:80; 443; 1000-2000.
	// +kubebuilder:validation:Optional
	DstPortList *string `json:"dstPortList" tf:"dst_port_list,omitempty"`

	// Speed limit mode, take the value [1 (speed limit based on source IP),2 (speed limit based on destination port)].
	// Speed limit mode, take the value [1 (speed limit based on source IP),2 (speed limit based on destination port)].
	// +kubebuilder:validation:Optional
	Mode *float64 `json:"mode" tf:"mode,omitempty"`

	// Packet rate pps.
	// Packet rate pps.
	// +kubebuilder:validation:Optional
	PacketRate *float64 `json:"packetRate" tf:"packet_rate,omitempty"`

	// IP protocol numbers, take the value[ ALL (all protocols),TCP (tcp protocol),UDP (udp protocol),SMP (smp protocol),1; 2-100 (custom protocol number range, up to 8)].
	// IP protocol numbers, take the value[ ALL (all protocols),TCP (tcp protocol),UDP (udp protocol),SMP (smp protocol),1; 2-100 (custom protocol number range, up to 8)].
	// +kubebuilder:validation:Optional
	ProtocolList *string `json:"protocolList" tf:"protocol_list,omitempty"`
}

type ListenersInitParameters struct {

	// Protocol type, desirable values tcp, udp, all.
	// Forwarding protocol, value [TCP, UDP].
	ForwardProtocol *string `json:"forwardProtocol,omitempty" tf:"forward_protocol,omitempty"`

	// Lower limit of forwarding listening port. Values: [1-65535].
	// Lower limit of forwarding listening port. Values: [1-65535].
	FrontendPort *float64 `json:"frontendPort,omitempty" tf:"frontend_port,omitempty"`

	// Upper limit of forwarding listening port. Values: [1-65535].
	// Upper limit of forwarding listening port. Values: [1-65535].
	FrontendPortEnd *float64 `json:"frontendPortEnd,omitempty" tf:"frontend_port_end,omitempty"`
}

type ListenersObservation struct {

	// Protocol type, desirable values tcp, udp, all.
	// Forwarding protocol, value [TCP, UDP].
	ForwardProtocol *string `json:"forwardProtocol,omitempty" tf:"forward_protocol,omitempty"`

	// Lower limit of forwarding listening port. Values: [1-65535].
	// Lower limit of forwarding listening port. Values: [1-65535].
	FrontendPort *float64 `json:"frontendPort,omitempty" tf:"frontend_port,omitempty"`

	// Upper limit of forwarding listening port. Values: [1-65535].
	// Upper limit of forwarding listening port. Values: [1-65535].
	FrontendPortEnd *float64 `json:"frontendPortEnd,omitempty" tf:"frontend_port_end,omitempty"`
}

type ListenersParameters struct {

	// Protocol type, desirable values tcp, udp, all.
	// Forwarding protocol, value [TCP, UDP].
	// +kubebuilder:validation:Optional
	ForwardProtocol *string `json:"forwardProtocol" tf:"forward_protocol,omitempty"`

	// Lower limit of forwarding listening port. Values: [1-65535].
	// Lower limit of forwarding listening port. Values: [1-65535].
	// +kubebuilder:validation:Optional
	FrontendPort *float64 `json:"frontendPort" tf:"frontend_port,omitempty"`

	// Upper limit of forwarding listening port. Values: [1-65535].
	// Upper limit of forwarding listening port. Values: [1-65535].
	// +kubebuilder:validation:Optional
	FrontendPortEnd *float64 `json:"frontendPortEnd" tf:"frontend_port_end,omitempty"`
}

type ProtocolBlockConfigInitParameters struct {

	// ICMP block, value [0 (block off), 1 (block on)].
	// ICMP block, value [0 (block off), 1 (block on)].
	DropIcmp *float64 `json:"dropIcmp,omitempty" tf:"drop_icmp,omitempty"`

	// Other block, value [0 (block off), 1 (block on)].
	// Other block, value [0 (block off), 1 (block on)].
	DropOther *float64 `json:"dropOther,omitempty" tf:"drop_other,omitempty"`

	// TCP block, value [0 (block off), 1 (block on)].
	// TCP block, value [0 (block off), 1 (block on)].
	DropTCP *float64 `json:"dropTcp,omitempty" tf:"drop_tcp,omitempty"`

	// UDP block, value [0 (block off), 1 (block on)].
	// UDP block, value [0 (block off), 1 (block on)].
	DropUDP *float64 `json:"dropUdp,omitempty" tf:"drop_udp,omitempty"`
}

type ProtocolBlockConfigObservation struct {

	// ICMP block, value [0 (block off), 1 (block on)].
	// ICMP block, value [0 (block off), 1 (block on)].
	DropIcmp *float64 `json:"dropIcmp,omitempty" tf:"drop_icmp,omitempty"`

	// Other block, value [0 (block off), 1 (block on)].
	// Other block, value [0 (block off), 1 (block on)].
	DropOther *float64 `json:"dropOther,omitempty" tf:"drop_other,omitempty"`

	// TCP block, value [0 (block off), 1 (block on)].
	// TCP block, value [0 (block off), 1 (block on)].
	DropTCP *float64 `json:"dropTcp,omitempty" tf:"drop_tcp,omitempty"`

	// UDP block, value [0 (block off), 1 (block on)].
	// UDP block, value [0 (block off), 1 (block on)].
	DropUDP *float64 `json:"dropUdp,omitempty" tf:"drop_udp,omitempty"`
}

type ProtocolBlockConfigParameters struct {

	// ICMP block, value [0 (block off), 1 (block on)].
	// ICMP block, value [0 (block off), 1 (block on)].
	// +kubebuilder:validation:Optional
	DropIcmp *float64 `json:"dropIcmp" tf:"drop_icmp,omitempty"`

	// Other block, value [0 (block off), 1 (block on)].
	// Other block, value [0 (block off), 1 (block on)].
	// +kubebuilder:validation:Optional
	DropOther *float64 `json:"dropOther" tf:"drop_other,omitempty"`

	// TCP block, value [0 (block off), 1 (block on)].
	// TCP block, value [0 (block off), 1 (block on)].
	// +kubebuilder:validation:Optional
	DropTCP *float64 `json:"dropTcp" tf:"drop_tcp,omitempty"`

	// UDP block, value [0 (block off), 1 (block on)].
	// UDP block, value [0 (block off), 1 (block on)].
	// +kubebuilder:validation:Optional
	DropUDP *float64 `json:"dropUdp" tf:"drop_udp,omitempty"`
}

type WaterPrintConfigInitParameters struct {

	// List of forwarding listeners to which the watermark belongs.
	// List of forwarding listeners to which the watermark belongs.
	Listeners []ListenersInitParameters `json:"listeners,omitempty" tf:"listeners,omitempty"`

	// Watermark offset, value range: [0-100].
	// Watermark offset, value range: [0-100].
	Offset *float64 `json:"offset,omitempty" tf:"offset,omitempty"`

	// Whether it is enabled, value [0 (manual open), 1 (immediate operation)].
	// Whether it is enabled, value [0 (manual open), 1 (immediate operation)].
	OpenStatus *float64 `json:"openStatus,omitempty" tf:"open_status,omitempty"`

	// Watermark check mode, value [checkall(normal mode), shortfpcheckall(simplified mode)].
	// Watermark check mode, value [`checkall`(normal mode), `shortfpcheckall`(simplified mode)].
	Verify *string `json:"verify,omitempty" tf:"verify,omitempty"`
}

type WaterPrintConfigObservation struct {

	// List of forwarding listeners to which the watermark belongs.
	// List of forwarding listeners to which the watermark belongs.
	Listeners []ListenersObservation `json:"listeners,omitempty" tf:"listeners,omitempty"`

	// Watermark offset, value range: [0-100].
	// Watermark offset, value range: [0-100].
	Offset *float64 `json:"offset,omitempty" tf:"offset,omitempty"`

	// Whether it is enabled, value [0 (manual open), 1 (immediate operation)].
	// Whether it is enabled, value [0 (manual open), 1 (immediate operation)].
	OpenStatus *float64 `json:"openStatus,omitempty" tf:"open_status,omitempty"`

	// Watermark check mode, value [checkall(normal mode), shortfpcheckall(simplified mode)].
	// Watermark check mode, value [`checkall`(normal mode), `shortfpcheckall`(simplified mode)].
	Verify *string `json:"verify,omitempty" tf:"verify,omitempty"`
}

type WaterPrintConfigParameters struct {

	// List of forwarding listeners to which the watermark belongs.
	// List of forwarding listeners to which the watermark belongs.
	// +kubebuilder:validation:Optional
	Listeners []ListenersParameters `json:"listeners" tf:"listeners,omitempty"`

	// Watermark offset, value range: [0-100].
	// Watermark offset, value range: [0-100].
	// +kubebuilder:validation:Optional
	Offset *float64 `json:"offset" tf:"offset,omitempty"`

	// Whether it is enabled, value [0 (manual open), 1 (immediate operation)].
	// Whether it is enabled, value [0 (manual open), 1 (immediate operation)].
	// +kubebuilder:validation:Optional
	OpenStatus *float64 `json:"openStatus" tf:"open_status,omitempty"`

	// Watermark check mode, value [checkall(normal mode), shortfpcheckall(simplified mode)].
	// Watermark check mode, value [`checkall`(normal mode), `shortfpcheckall`(simplified mode)].
	// +kubebuilder:validation:Optional
	Verify *string `json:"verify" tf:"verify,omitempty"`
}

// DdosPolicyV2Spec defines the desired state of DdosPolicyV2
type DdosPolicyV2Spec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     DdosPolicyV2Parameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider DdosPolicyV2InitParameters `json:"initProvider,omitempty"`
}

// DdosPolicyV2Status defines the observed state of DdosPolicyV2.
type DdosPolicyV2Status struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        DdosPolicyV2Observation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// DdosPolicyV2 is the Schema for the DdosPolicyV2s API. Use this resource to create dayu DDoS policy v2
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,tencentcloud}
type DdosPolicyV2 struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.resourceId) || (has(self.initProvider) && has(self.initProvider.resourceId))",message="spec.forProvider.resourceId is a required parameter"
	Spec   DdosPolicyV2Spec   `json:"spec"`
	Status DdosPolicyV2Status `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// DdosPolicyV2List contains a list of DdosPolicyV2s
type DdosPolicyV2List struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []DdosPolicyV2 `json:"items"`
}

// Repository type metadata.
var (
	DdosPolicyV2_Kind             = "DdosPolicyV2"
	DdosPolicyV2_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: DdosPolicyV2_Kind}.String()
	DdosPolicyV2_KindAPIVersion   = DdosPolicyV2_Kind + "." + CRDGroupVersion.String()
	DdosPolicyV2_GroupVersionKind = CRDGroupVersion.WithKind(DdosPolicyV2_Kind)
)

func init() {
	SchemeBuilder.Register(&DdosPolicyV2{}, &DdosPolicyV2List{})
}
