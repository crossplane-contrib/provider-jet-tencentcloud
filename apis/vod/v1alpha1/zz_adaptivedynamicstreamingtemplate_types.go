// SPDX-FileCopyrightText: 2023 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AdaptiveDynamicStreamingTemplateInitParameters struct {

	// Template description. Length limit: 256 characters.
	// Template description. Length limit: 256 characters.
	Comment *string `json:"comment,omitempty" tf:"comment,omitempty"`

	// Whether to prohibit transcoding video from low bitrate to high bitrate. Valid values: false,true. false: no, true: yes. Default value: false.
	// Whether to prohibit transcoding video from low bitrate to high bitrate. Valid values: `false`,`true`. `false`: no, `true`: yes. Default value: `false`.
	DisableHigherVideoBitrate *bool `json:"disableHigherVideoBitrate,omitempty" tf:"disable_higher_video_bitrate,omitempty"`

	// Whether to prohibit transcoding from low resolution to high resolution. Valid values: false,true. false: no, true: yes. Default value: false.
	// Whether to prohibit transcoding from low resolution to high resolution. Valid values: `false`,`true`. `false`: no, `true`: yes. Default value: `false`.
	DisableHigherVideoResolution *bool `json:"disableHigherVideoResolution,omitempty" tf:"disable_higher_video_resolution,omitempty"`

	// DRM scheme type. Valid values: SimpleAES. If this field is an empty string, DRM will not be performed on the video.
	// DRM scheme type. Valid values: `SimpleAES`. If this field is an empty string, DRM will not be performed on the video.
	DrmType *string `json:"drmType,omitempty" tf:"drm_type,omitempty"`

	// Adaptive bitstream format. Valid values: HLS.
	// Adaptive bitstream format. Valid values: `HLS`.
	Format *string `json:"format,omitempty" tf:"format,omitempty"`

	// Template name. Length limit: 64 characters.
	// Template name. Length limit: 64 characters.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Segment type, valid when Format is HLS, optional values:
	// Segment type, valid when Format is HLS, optional values:
	// - ts: ts segment;
	// - fmp4: fmp4 segment;
	// Default value: ts.
	SegmentType *string `json:"segmentType,omitempty" tf:"segment_type,omitempty"`

	// List of AdaptiveStreamTemplate parameter information of output substream for adaptive bitrate streaming. Up to 10 substreams can be output. Note: the frame rate of all substreams must be the same; otherwise, the frame rate of the first substream will be used as the output frame rate.
	// List of AdaptiveStreamTemplate parameter information of output substream for adaptive bitrate streaming. Up to 10 substreams can be output. Note: the frame rate of all substreams must be the same; otherwise, the frame rate of the first substream will be used as the output frame rate.
	StreamInfo []StreamInfoInitParameters `json:"streamInfo,omitempty" tf:"stream_info,omitempty"`

	// The VOD application ID. For customers who activate VOD service from December 25, 2023, if they want to access resources in a VOD application (whether it's the default application or a newly created one), they must fill in this field with the application ID.
	// The VOD [application](https://intl.cloud.tencent.com/document/product/266/14574) ID. For customers who activate VOD service from December 25, 2023, if they want to access resources in a VOD application (whether it's the default application or a newly created one), they must fill in this field with the application ID.
	SubAppID *float64 `json:"subAppId,omitempty" tf:"sub_app_id,omitempty"`
}

type AdaptiveDynamicStreamingTemplateObservation struct {

	// Template description. Length limit: 256 characters.
	// Template description. Length limit: 256 characters.
	Comment *string `json:"comment,omitempty" tf:"comment,omitempty"`

	// Creation time of template in ISO date format.
	// Creation time of template in ISO date format.
	CreateTime *string `json:"createTime,omitempty" tf:"create_time,omitempty"`

	// Whether to prohibit transcoding video from low bitrate to high bitrate. Valid values: false,true. false: no, true: yes. Default value: false.
	// Whether to prohibit transcoding video from low bitrate to high bitrate. Valid values: `false`,`true`. `false`: no, `true`: yes. Default value: `false`.
	DisableHigherVideoBitrate *bool `json:"disableHigherVideoBitrate,omitempty" tf:"disable_higher_video_bitrate,omitempty"`

	// Whether to prohibit transcoding from low resolution to high resolution. Valid values: false,true. false: no, true: yes. Default value: false.
	// Whether to prohibit transcoding from low resolution to high resolution. Valid values: `false`,`true`. `false`: no, `true`: yes. Default value: `false`.
	DisableHigherVideoResolution *bool `json:"disableHigherVideoResolution,omitempty" tf:"disable_higher_video_resolution,omitempty"`

	// DRM scheme type. Valid values: SimpleAES. If this field is an empty string, DRM will not be performed on the video.
	// DRM scheme type. Valid values: `SimpleAES`. If this field is an empty string, DRM will not be performed on the video.
	DrmType *string `json:"drmType,omitempty" tf:"drm_type,omitempty"`

	// Adaptive bitstream format. Valid values: HLS.
	// Adaptive bitstream format. Valid values: `HLS`.
	Format *string `json:"format,omitempty" tf:"format,omitempty"`

	// ID of the resource.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// Template name. Length limit: 64 characters.
	// Template name. Length limit: 64 characters.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Segment type, valid when Format is HLS, optional values:
	// Segment type, valid when Format is HLS, optional values:
	// - ts: ts segment;
	// - fmp4: fmp4 segment;
	// Default value: ts.
	SegmentType *string `json:"segmentType,omitempty" tf:"segment_type,omitempty"`

	// List of AdaptiveStreamTemplate parameter information of output substream for adaptive bitrate streaming. Up to 10 substreams can be output. Note: the frame rate of all substreams must be the same; otherwise, the frame rate of the first substream will be used as the output frame rate.
	// List of AdaptiveStreamTemplate parameter information of output substream for adaptive bitrate streaming. Up to 10 substreams can be output. Note: the frame rate of all substreams must be the same; otherwise, the frame rate of the first substream will be used as the output frame rate.
	StreamInfo []StreamInfoObservation `json:"streamInfo,omitempty" tf:"stream_info,omitempty"`

	// The VOD application ID. For customers who activate VOD service from December 25, 2023, if they want to access resources in a VOD application (whether it's the default application or a newly created one), they must fill in this field with the application ID.
	// The VOD [application](https://intl.cloud.tencent.com/document/product/266/14574) ID. For customers who activate VOD service from December 25, 2023, if they want to access resources in a VOD application (whether it's the default application or a newly created one), they must fill in this field with the application ID.
	SubAppID *float64 `json:"subAppId,omitempty" tf:"sub_app_id,omitempty"`

	// Last modified time of template in ISO date format.
	// Last modified time of template in ISO date format.
	UpdateTime *string `json:"updateTime,omitempty" tf:"update_time,omitempty"`
}

type AdaptiveDynamicStreamingTemplateParameters struct {

	// Template description. Length limit: 256 characters.
	// Template description. Length limit: 256 characters.
	// +kubebuilder:validation:Optional
	Comment *string `json:"comment,omitempty" tf:"comment,omitempty"`

	// Whether to prohibit transcoding video from low bitrate to high bitrate. Valid values: false,true. false: no, true: yes. Default value: false.
	// Whether to prohibit transcoding video from low bitrate to high bitrate. Valid values: `false`,`true`. `false`: no, `true`: yes. Default value: `false`.
	// +kubebuilder:validation:Optional
	DisableHigherVideoBitrate *bool `json:"disableHigherVideoBitrate,omitempty" tf:"disable_higher_video_bitrate,omitempty"`

	// Whether to prohibit transcoding from low resolution to high resolution. Valid values: false,true. false: no, true: yes. Default value: false.
	// Whether to prohibit transcoding from low resolution to high resolution. Valid values: `false`,`true`. `false`: no, `true`: yes. Default value: `false`.
	// +kubebuilder:validation:Optional
	DisableHigherVideoResolution *bool `json:"disableHigherVideoResolution,omitempty" tf:"disable_higher_video_resolution,omitempty"`

	// DRM scheme type. Valid values: SimpleAES. If this field is an empty string, DRM will not be performed on the video.
	// DRM scheme type. Valid values: `SimpleAES`. If this field is an empty string, DRM will not be performed on the video.
	// +kubebuilder:validation:Optional
	DrmType *string `json:"drmType,omitempty" tf:"drm_type,omitempty"`

	// Adaptive bitstream format. Valid values: HLS.
	// Adaptive bitstream format. Valid values: `HLS`.
	// +kubebuilder:validation:Optional
	Format *string `json:"format,omitempty" tf:"format,omitempty"`

	// Template name. Length limit: 64 characters.
	// Template name. Length limit: 64 characters.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Segment type, valid when Format is HLS, optional values:
	// Segment type, valid when Format is HLS, optional values:
	// - ts: ts segment;
	// - fmp4: fmp4 segment;
	// Default value: ts.
	// +kubebuilder:validation:Optional
	SegmentType *string `json:"segmentType,omitempty" tf:"segment_type,omitempty"`

	// List of AdaptiveStreamTemplate parameter information of output substream for adaptive bitrate streaming. Up to 10 substreams can be output. Note: the frame rate of all substreams must be the same; otherwise, the frame rate of the first substream will be used as the output frame rate.
	// List of AdaptiveStreamTemplate parameter information of output substream for adaptive bitrate streaming. Up to 10 substreams can be output. Note: the frame rate of all substreams must be the same; otherwise, the frame rate of the first substream will be used as the output frame rate.
	// +kubebuilder:validation:Optional
	StreamInfo []StreamInfoParameters `json:"streamInfo,omitempty" tf:"stream_info,omitempty"`

	// The VOD application ID. For customers who activate VOD service from December 25, 2023, if they want to access resources in a VOD application (whether it's the default application or a newly created one), they must fill in this field with the application ID.
	// The VOD [application](https://intl.cloud.tencent.com/document/product/266/14574) ID. For customers who activate VOD service from December 25, 2023, if they want to access resources in a VOD application (whether it's the default application or a newly created one), they must fill in this field with the application ID.
	// +kubebuilder:validation:Optional
	SubAppID *float64 `json:"subAppId,omitempty" tf:"sub_app_id,omitempty"`
}

type AudioInitParameters struct {

	// Audio channel system. Valid values: mono, dual, stereo. Default value: dual.
	// Audio channel system. Valid values: mono, dual, stereo. Default value: dual.
	AudioChannel *string `json:"audioChannel,omitempty" tf:"audio_channel,omitempty"`

	// Audio stream bitrate in Kbps. Value range: 0 and [26, 256]. If the value is 0, the bitrate of the audio stream will be the same as that of the original audio.
	// Audio stream bitrate in Kbps. Value range: `0` and `[26, 256]`. If the value is `0`, the bitrate of the audio stream will be the same as that of the original audio.
	Bitrate *float64 `json:"bitrate,omitempty" tf:"bitrate,omitempty"`

	// Audio stream encoder. Valid value are: libfdk_aac and libmp3lame. while libfdk_aac is recommended.
	// Audio stream encoder. Valid value are: `libfdk_aac` and `libmp3lame`. while `libfdk_aac` is recommended.
	Codec *string `json:"codec,omitempty" tf:"codec,omitempty"`

	// Audio stream sample rate. Valid values: 32000, 44100, 48000Hz.
	// Audio stream sample rate. Valid values: `32000`, `44100`, `48000`Hz.
	SampleRate *float64 `json:"sampleRate,omitempty" tf:"sample_rate,omitempty"`
}

type AudioObservation struct {

	// Audio channel system. Valid values: mono, dual, stereo. Default value: dual.
	// Audio channel system. Valid values: mono, dual, stereo. Default value: dual.
	AudioChannel *string `json:"audioChannel,omitempty" tf:"audio_channel,omitempty"`

	// Audio stream bitrate in Kbps. Value range: 0 and [26, 256]. If the value is 0, the bitrate of the audio stream will be the same as that of the original audio.
	// Audio stream bitrate in Kbps. Value range: `0` and `[26, 256]`. If the value is `0`, the bitrate of the audio stream will be the same as that of the original audio.
	Bitrate *float64 `json:"bitrate,omitempty" tf:"bitrate,omitempty"`

	// Audio stream encoder. Valid value are: libfdk_aac and libmp3lame. while libfdk_aac is recommended.
	// Audio stream encoder. Valid value are: `libfdk_aac` and `libmp3lame`. while `libfdk_aac` is recommended.
	Codec *string `json:"codec,omitempty" tf:"codec,omitempty"`

	// Audio stream sample rate. Valid values: 32000, 44100, 48000Hz.
	// Audio stream sample rate. Valid values: `32000`, `44100`, `48000`Hz.
	SampleRate *float64 `json:"sampleRate,omitempty" tf:"sample_rate,omitempty"`
}

type AudioParameters struct {

	// Audio channel system. Valid values: mono, dual, stereo. Default value: dual.
	// Audio channel system. Valid values: mono, dual, stereo. Default value: dual.
	// +kubebuilder:validation:Optional
	AudioChannel *string `json:"audioChannel,omitempty" tf:"audio_channel,omitempty"`

	// Audio stream bitrate in Kbps. Value range: 0 and [26, 256]. If the value is 0, the bitrate of the audio stream will be the same as that of the original audio.
	// Audio stream bitrate in Kbps. Value range: `0` and `[26, 256]`. If the value is `0`, the bitrate of the audio stream will be the same as that of the original audio.
	// +kubebuilder:validation:Optional
	Bitrate *float64 `json:"bitrate" tf:"bitrate,omitempty"`

	// Audio stream encoder. Valid value are: libfdk_aac and libmp3lame. while libfdk_aac is recommended.
	// Audio stream encoder. Valid value are: `libfdk_aac` and `libmp3lame`. while `libfdk_aac` is recommended.
	// +kubebuilder:validation:Optional
	Codec *string `json:"codec" tf:"codec,omitempty"`

	// Audio stream sample rate. Valid values: 32000, 44100, 48000Hz.
	// Audio stream sample rate. Valid values: `32000`, `44100`, `48000`Hz.
	// +kubebuilder:validation:Optional
	SampleRate *float64 `json:"sampleRate" tf:"sample_rate,omitempty"`
}

type StreamInfoInitParameters struct {

	// Audio parameter information.
	// Audio parameter information.
	Audio []AudioInitParameters `json:"audio,omitempty" tf:"audio,omitempty"`

	// Whether to remove audio stream. Valid values: false: no, true: yes. false by default.
	// Whether to remove audio stream. Valid values: `false`: no, `true`: yes. `false` by default.
	RemoveAudio *bool `json:"removeAudio,omitempty" tf:"remove_audio,omitempty"`

	// Whether to remove video stream. Valid values: false: no, true: yes. false by default.
	// Whether to remove video stream. Valid values: `false`: no, `true`: yes. `false` by default.
	RemoveVideo *bool `json:"removeVideo,omitempty" tf:"remove_video,omitempty"`

	// Extremely fast HD transcoding parameters.
	// Extremely fast HD transcoding parameters.
	TehdConfig []TehdConfigInitParameters `json:"tehdConfig,omitempty" tf:"tehd_config,omitempty"`

	// Video parameter information.
	// Video parameter information.
	Video []VideoInitParameters `json:"video,omitempty" tf:"video,omitempty"`
}

type StreamInfoObservation struct {

	// Audio parameter information.
	// Audio parameter information.
	Audio []AudioObservation `json:"audio,omitempty" tf:"audio,omitempty"`

	// Whether to remove audio stream. Valid values: false: no, true: yes. false by default.
	// Whether to remove audio stream. Valid values: `false`: no, `true`: yes. `false` by default.
	RemoveAudio *bool `json:"removeAudio,omitempty" tf:"remove_audio,omitempty"`

	// Whether to remove video stream. Valid values: false: no, true: yes. false by default.
	// Whether to remove video stream. Valid values: `false`: no, `true`: yes. `false` by default.
	RemoveVideo *bool `json:"removeVideo,omitempty" tf:"remove_video,omitempty"`

	// Extremely fast HD transcoding parameters.
	// Extremely fast HD transcoding parameters.
	TehdConfig []TehdConfigObservation `json:"tehdConfig,omitempty" tf:"tehd_config,omitempty"`

	// Video parameter information.
	// Video parameter information.
	Video []VideoObservation `json:"video,omitempty" tf:"video,omitempty"`
}

type StreamInfoParameters struct {

	// Audio parameter information.
	// Audio parameter information.
	// +kubebuilder:validation:Optional
	Audio []AudioParameters `json:"audio" tf:"audio,omitempty"`

	// Whether to remove audio stream. Valid values: false: no, true: yes. false by default.
	// Whether to remove audio stream. Valid values: `false`: no, `true`: yes. `false` by default.
	// +kubebuilder:validation:Optional
	RemoveAudio *bool `json:"removeAudio,omitempty" tf:"remove_audio,omitempty"`

	// Whether to remove video stream. Valid values: false: no, true: yes. false by default.
	// Whether to remove video stream. Valid values: `false`: no, `true`: yes. `false` by default.
	// +kubebuilder:validation:Optional
	RemoveVideo *bool `json:"removeVideo,omitempty" tf:"remove_video,omitempty"`

	// Extremely fast HD transcoding parameters.
	// Extremely fast HD transcoding parameters.
	// +kubebuilder:validation:Optional
	TehdConfig []TehdConfigParameters `json:"tehdConfig,omitempty" tf:"tehd_config,omitempty"`

	// Video parameter information.
	// Video parameter information.
	// +kubebuilder:validation:Optional
	Video []VideoParameters `json:"video" tf:"video,omitempty"`
}

type TehdConfigInitParameters struct {

	// Video bitrate limit, which is valid when Type specifies extreme speed HD type. If you leave it empty or enter 0, there is no video bitrate limit.
	// Video bitrate limit, which is valid when Type specifies extreme speed HD type. If you leave it empty or enter 0, there is no video bitrate limit.
	MaxVideoBitrate *float64 `json:"maxVideoBitrate,omitempty" tf:"max_video_bitrate,omitempty"`

	// Extreme high-speed HD type, available values:
	// Extreme high-speed HD type, available values:
	// - TEHD-100: super high definition-100th;
	// - OFF: turn off Ultra High definition.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type TehdConfigObservation struct {

	// Video bitrate limit, which is valid when Type specifies extreme speed HD type. If you leave it empty or enter 0, there is no video bitrate limit.
	// Video bitrate limit, which is valid when Type specifies extreme speed HD type. If you leave it empty or enter 0, there is no video bitrate limit.
	MaxVideoBitrate *float64 `json:"maxVideoBitrate,omitempty" tf:"max_video_bitrate,omitempty"`

	// Extreme high-speed HD type, available values:
	// Extreme high-speed HD type, available values:
	// - TEHD-100: super high definition-100th;
	// - OFF: turn off Ultra High definition.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type TehdConfigParameters struct {

	// Video bitrate limit, which is valid when Type specifies extreme speed HD type. If you leave it empty or enter 0, there is no video bitrate limit.
	// Video bitrate limit, which is valid when Type specifies extreme speed HD type. If you leave it empty or enter 0, there is no video bitrate limit.
	// +kubebuilder:validation:Optional
	MaxVideoBitrate *float64 `json:"maxVideoBitrate,omitempty" tf:"max_video_bitrate,omitempty"`

	// Extreme high-speed HD type, available values:
	// Extreme high-speed HD type, available values:
	// - TEHD-100: super high definition-100th;
	// - OFF: turn off Ultra High definition.
	// +kubebuilder:validation:Optional
	Type *string `json:"type" tf:"type,omitempty"`
}

type VideoInitParameters struct {

	// Audio stream bitrate in Kbps. Value range: 0 and [26, 256]. If the value is 0, the bitrate of the audio stream will be the same as that of the original audio.
	// Bitrate of video stream in Kbps. Value range: `0` and `[128, 35000]`. If the value is `0`, the bitrate of the video will be the same as that of the source video.
	Bitrate *float64 `json:"bitrate,omitempty" tf:"bitrate,omitempty"`

	// Audio stream encoder. Valid value are: libfdk_aac and libmp3lame. while libfdk_aac is recommended.
	// Video stream encoder. Valid values: `libx264`,`libx265`,`av1`. `libx264`: H.264, `libx265`: H.265, `av1`: AOMedia Video 1. Currently, a resolution within 640x480 must be specified for `H.265`. and the `av1` container only supports mp4.
	Codec *string `json:"codec,omitempty" tf:"codec,omitempty"`

	// Encoding label, valid only if the encoding format of the video stream is H.265 encoding. Available values:
	// Encoding label, valid only if the encoding format of the video stream is H.265 encoding. Available values:
	// - hvc1: stands for hvc1 tag;
	// - hev1: stands for the hev1 tag;
	// Default value: hvc1.
	CodecTag *string `json:"codecTag,omitempty" tf:"codec_tag,omitempty"`

	// Fill type. Fill refers to the way of processing a screenshot when its aspect ratio is different from that of the source video. The following fill types are supported: stretch: stretch. The screenshot will be stretched frame by frame to match the aspect ratio of the source video, which may make the screenshot shorter or longer; black: fill with black. This option retains the aspect ratio of the source video for the screenshot and fills the unmatched area with black color blocks. Default value: black. Note: this field may return null, indicating that no valid values can be obtained.
	// Fill type. Fill refers to the way of processing a screenshot when its aspect ratio is different from that of the source video. The following fill types are supported: `stretch`: stretch. The screenshot will be stretched frame by frame to match the aspect ratio of the source video, which may make the screenshot shorter or longer; `black`: fill with black. This option retains the aspect ratio of the source video for the screenshot and fills the unmatched area with black color blocks. Default value: black. Note: this field may return null, indicating that no valid values can be obtained.
	FillType *string `json:"fillType,omitempty" tf:"fill_type,omitempty"`

	// Video frame rate in Hz. Value range: [0, 60]. If the value is 0, the frame rate will be the same as that of the source video.
	// Video frame rate in Hz. Value range: `[0, 60]`. If the value is `0`, the frame rate will be the same as that of the source video.
	Fps *float64 `json:"fps,omitempty" tf:"fps,omitempty"`

	// Interval between Keyframe I frames, value range: 0 and [1, 100000], unit: number of frames. When you fill in 0 or leave it empty, the gop length is automatically set.
	// Interval between Keyframe I frames, value range: 0 and [1, 100000], unit: number of frames. When you fill in 0 or leave it empty, the gop length is automatically set.
	Gop *float64 `json:"gop,omitempty" tf:"gop,omitempty"`

	// Maximum value of the height (or short side) of a video stream in px. Value range: 0 and [128, 4096]. If both width and height are 0, the resolution will be the same as that of the source video; If width is 0, but height is not 0, width will be proportionally scaled; If width is not 0, but height is 0, height will be proportionally scaled; If both width and height are not 0, the custom resolution will be used. Default value: 0. Note: this field may return null, indicating that no valid values can be obtained.
	// Maximum value of the height (or short side) of a video stream in px. Value range: `0` and `[128, 4096]`. If both `width` and `height` are `0`, the resolution will be the same as that of the source video; If `width` is `0`, but `height` is not `0`, `width` will be proportionally scaled; If `width` is not `0`, but `height` is `0`, `height` will be proportionally scaled; If both `width` and `height` are not `0`, the custom resolution will be used. Default value: `0`. Note: this field may return null, indicating that no valid values can be obtained.
	Height *float64 `json:"height,omitempty" tf:"height,omitempty"`

	// Whether the transcoding output still maintains HDR when the original video is HDR (High Dynamic Range). Value range:
	// Whether the transcoding output still maintains HDR when the original video is HDR (High Dynamic Range). Value range:
	// - ON: if the original file is HDR, the transcoding output remains HDR;, otherwise the transcoding output is SDR (Standard Dynamic Range);
	// - OFF: regardless of whether the original file is HDR or SDR, the transcoding output is SDR;
	// Default value: OFF.
	PreserveHdrSwitch *string `json:"preserveHdrSwitch,omitempty" tf:"preserve_hdr_switch,omitempty"`

	// Resolution adaption. Valid values: true,false. true: enabled. In this case, width represents the long side of a video, while height the short side; false: disabled. In this case, width represents the width of a video, while height the height. Default value: true. Note: this field may return null, indicating that no valid values can be obtained.
	// Resolution adaption. Valid values: `true`,`false`. `true`: enabled. In this case, `width` represents the long side of a video, while `height` the short side; `false`: disabled. In this case, `width` represents the width of a video, while `height` the height. Default value: `true`. Note: this field may return null, indicating that no valid values can be obtained.
	ResolutionAdaptive *bool `json:"resolutionAdaptive,omitempty" tf:"resolution_adaptive,omitempty"`

	// Video constant bit rate control factor, value range is [1,51].
	// Note:
	// Video constant bit rate control factor, value range is [1,51].
	// Note:
	// - If this parameter is specified, the bitrate control method of CRF will be used for transcoding (the video bitrate will no longer take effect);
	// - This field is required when the video stream encoding format is H.266. The recommended value is 28;
	// - If there are no special requirements, it is not recommended to specify this parameter.
	Vcrf *float64 `json:"vcrf,omitempty" tf:"vcrf,omitempty"`

	// Maximum value of the width (or long side) of a video stream in px. Value range: 0 and [128, 4096]. If both width and height are 0, the resolution will be the same as that of the source video; If width is 0, but height is not 0, width will be proportionally scaled; If width is not 0, but height is 0, height will be proportionally scaled; If both width and height are not 0, the custom resolution will be used. Default value: 0. Note: this field may return null, indicating that no valid values can be obtained.
	// Maximum value of the width (or long side) of a video stream in px. Value range: `0` and `[128, 4096]`. If both `width` and `height` are `0`, the resolution will be the same as that of the source video; If `width` is `0`, but `height` is not `0`, `width` will be proportionally scaled; If `width` is not `0`, but `height` is `0`, `height` will be proportionally scaled; If both `width` and `height` are not `0`, the custom resolution will be used. Default value: `0`. Note: this field may return null, indicating that no valid values can be obtained.
	Width *float64 `json:"width,omitempty" tf:"width,omitempty"`
}

type VideoObservation struct {

	// Audio stream bitrate in Kbps. Value range: 0 and [26, 256]. If the value is 0, the bitrate of the audio stream will be the same as that of the original audio.
	// Bitrate of video stream in Kbps. Value range: `0` and `[128, 35000]`. If the value is `0`, the bitrate of the video will be the same as that of the source video.
	Bitrate *float64 `json:"bitrate,omitempty" tf:"bitrate,omitempty"`

	// Audio stream encoder. Valid value are: libfdk_aac and libmp3lame. while libfdk_aac is recommended.
	// Video stream encoder. Valid values: `libx264`,`libx265`,`av1`. `libx264`: H.264, `libx265`: H.265, `av1`: AOMedia Video 1. Currently, a resolution within 640x480 must be specified for `H.265`. and the `av1` container only supports mp4.
	Codec *string `json:"codec,omitempty" tf:"codec,omitempty"`

	// Encoding label, valid only if the encoding format of the video stream is H.265 encoding. Available values:
	// Encoding label, valid only if the encoding format of the video stream is H.265 encoding. Available values:
	// - hvc1: stands for hvc1 tag;
	// - hev1: stands for the hev1 tag;
	// Default value: hvc1.
	CodecTag *string `json:"codecTag,omitempty" tf:"codec_tag,omitempty"`

	// Fill type. Fill refers to the way of processing a screenshot when its aspect ratio is different from that of the source video. The following fill types are supported: stretch: stretch. The screenshot will be stretched frame by frame to match the aspect ratio of the source video, which may make the screenshot shorter or longer; black: fill with black. This option retains the aspect ratio of the source video for the screenshot and fills the unmatched area with black color blocks. Default value: black. Note: this field may return null, indicating that no valid values can be obtained.
	// Fill type. Fill refers to the way of processing a screenshot when its aspect ratio is different from that of the source video. The following fill types are supported: `stretch`: stretch. The screenshot will be stretched frame by frame to match the aspect ratio of the source video, which may make the screenshot shorter or longer; `black`: fill with black. This option retains the aspect ratio of the source video for the screenshot and fills the unmatched area with black color blocks. Default value: black. Note: this field may return null, indicating that no valid values can be obtained.
	FillType *string `json:"fillType,omitempty" tf:"fill_type,omitempty"`

	// Video frame rate in Hz. Value range: [0, 60]. If the value is 0, the frame rate will be the same as that of the source video.
	// Video frame rate in Hz. Value range: `[0, 60]`. If the value is `0`, the frame rate will be the same as that of the source video.
	Fps *float64 `json:"fps,omitempty" tf:"fps,omitempty"`

	// Interval between Keyframe I frames, value range: 0 and [1, 100000], unit: number of frames. When you fill in 0 or leave it empty, the gop length is automatically set.
	// Interval between Keyframe I frames, value range: 0 and [1, 100000], unit: number of frames. When you fill in 0 or leave it empty, the gop length is automatically set.
	Gop *float64 `json:"gop,omitempty" tf:"gop,omitempty"`

	// Maximum value of the height (or short side) of a video stream in px. Value range: 0 and [128, 4096]. If both width and height are 0, the resolution will be the same as that of the source video; If width is 0, but height is not 0, width will be proportionally scaled; If width is not 0, but height is 0, height will be proportionally scaled; If both width and height are not 0, the custom resolution will be used. Default value: 0. Note: this field may return null, indicating that no valid values can be obtained.
	// Maximum value of the height (or short side) of a video stream in px. Value range: `0` and `[128, 4096]`. If both `width` and `height` are `0`, the resolution will be the same as that of the source video; If `width` is `0`, but `height` is not `0`, `width` will be proportionally scaled; If `width` is not `0`, but `height` is `0`, `height` will be proportionally scaled; If both `width` and `height` are not `0`, the custom resolution will be used. Default value: `0`. Note: this field may return null, indicating that no valid values can be obtained.
	Height *float64 `json:"height,omitempty" tf:"height,omitempty"`

	// Whether the transcoding output still maintains HDR when the original video is HDR (High Dynamic Range). Value range:
	// Whether the transcoding output still maintains HDR when the original video is HDR (High Dynamic Range). Value range:
	// - ON: if the original file is HDR, the transcoding output remains HDR;, otherwise the transcoding output is SDR (Standard Dynamic Range);
	// - OFF: regardless of whether the original file is HDR or SDR, the transcoding output is SDR;
	// Default value: OFF.
	PreserveHdrSwitch *string `json:"preserveHdrSwitch,omitempty" tf:"preserve_hdr_switch,omitempty"`

	// Resolution adaption. Valid values: true,false. true: enabled. In this case, width represents the long side of a video, while height the short side; false: disabled. In this case, width represents the width of a video, while height the height. Default value: true. Note: this field may return null, indicating that no valid values can be obtained.
	// Resolution adaption. Valid values: `true`,`false`. `true`: enabled. In this case, `width` represents the long side of a video, while `height` the short side; `false`: disabled. In this case, `width` represents the width of a video, while `height` the height. Default value: `true`. Note: this field may return null, indicating that no valid values can be obtained.
	ResolutionAdaptive *bool `json:"resolutionAdaptive,omitempty" tf:"resolution_adaptive,omitempty"`

	// Video constant bit rate control factor, value range is [1,51].
	// Note:
	// Video constant bit rate control factor, value range is [1,51].
	// Note:
	// - If this parameter is specified, the bitrate control method of CRF will be used for transcoding (the video bitrate will no longer take effect);
	// - This field is required when the video stream encoding format is H.266. The recommended value is 28;
	// - If there are no special requirements, it is not recommended to specify this parameter.
	Vcrf *float64 `json:"vcrf,omitempty" tf:"vcrf,omitempty"`

	// Maximum value of the width (or long side) of a video stream in px. Value range: 0 and [128, 4096]. If both width and height are 0, the resolution will be the same as that of the source video; If width is 0, but height is not 0, width will be proportionally scaled; If width is not 0, but height is 0, height will be proportionally scaled; If both width and height are not 0, the custom resolution will be used. Default value: 0. Note: this field may return null, indicating that no valid values can be obtained.
	// Maximum value of the width (or long side) of a video stream in px. Value range: `0` and `[128, 4096]`. If both `width` and `height` are `0`, the resolution will be the same as that of the source video; If `width` is `0`, but `height` is not `0`, `width` will be proportionally scaled; If `width` is not `0`, but `height` is `0`, `height` will be proportionally scaled; If both `width` and `height` are not `0`, the custom resolution will be used. Default value: `0`. Note: this field may return null, indicating that no valid values can be obtained.
	Width *float64 `json:"width,omitempty" tf:"width,omitempty"`
}

type VideoParameters struct {

	// Audio stream bitrate in Kbps. Value range: 0 and [26, 256]. If the value is 0, the bitrate of the audio stream will be the same as that of the original audio.
	// Bitrate of video stream in Kbps. Value range: `0` and `[128, 35000]`. If the value is `0`, the bitrate of the video will be the same as that of the source video.
	// +kubebuilder:validation:Optional
	Bitrate *float64 `json:"bitrate" tf:"bitrate,omitempty"`

	// Audio stream encoder. Valid value are: libfdk_aac and libmp3lame. while libfdk_aac is recommended.
	// Video stream encoder. Valid values: `libx264`,`libx265`,`av1`. `libx264`: H.264, `libx265`: H.265, `av1`: AOMedia Video 1. Currently, a resolution within 640x480 must be specified for `H.265`. and the `av1` container only supports mp4.
	// +kubebuilder:validation:Optional
	Codec *string `json:"codec" tf:"codec,omitempty"`

	// Encoding label, valid only if the encoding format of the video stream is H.265 encoding. Available values:
	// Encoding label, valid only if the encoding format of the video stream is H.265 encoding. Available values:
	// - hvc1: stands for hvc1 tag;
	// - hev1: stands for the hev1 tag;
	// Default value: hvc1.
	// +kubebuilder:validation:Optional
	CodecTag *string `json:"codecTag,omitempty" tf:"codec_tag,omitempty"`

	// Fill type. Fill refers to the way of processing a screenshot when its aspect ratio is different from that of the source video. The following fill types are supported: stretch: stretch. The screenshot will be stretched frame by frame to match the aspect ratio of the source video, which may make the screenshot shorter or longer; black: fill with black. This option retains the aspect ratio of the source video for the screenshot and fills the unmatched area with black color blocks. Default value: black. Note: this field may return null, indicating that no valid values can be obtained.
	// Fill type. Fill refers to the way of processing a screenshot when its aspect ratio is different from that of the source video. The following fill types are supported: `stretch`: stretch. The screenshot will be stretched frame by frame to match the aspect ratio of the source video, which may make the screenshot shorter or longer; `black`: fill with black. This option retains the aspect ratio of the source video for the screenshot and fills the unmatched area with black color blocks. Default value: black. Note: this field may return null, indicating that no valid values can be obtained.
	// +kubebuilder:validation:Optional
	FillType *string `json:"fillType,omitempty" tf:"fill_type,omitempty"`

	// Video frame rate in Hz. Value range: [0, 60]. If the value is 0, the frame rate will be the same as that of the source video.
	// Video frame rate in Hz. Value range: `[0, 60]`. If the value is `0`, the frame rate will be the same as that of the source video.
	// +kubebuilder:validation:Optional
	Fps *float64 `json:"fps" tf:"fps,omitempty"`

	// Interval between Keyframe I frames, value range: 0 and [1, 100000], unit: number of frames. When you fill in 0 or leave it empty, the gop length is automatically set.
	// Interval between Keyframe I frames, value range: 0 and [1, 100000], unit: number of frames. When you fill in 0 or leave it empty, the gop length is automatically set.
	// +kubebuilder:validation:Optional
	Gop *float64 `json:"gop,omitempty" tf:"gop,omitempty"`

	// Maximum value of the height (or short side) of a video stream in px. Value range: 0 and [128, 4096]. If both width and height are 0, the resolution will be the same as that of the source video; If width is 0, but height is not 0, width will be proportionally scaled; If width is not 0, but height is 0, height will be proportionally scaled; If both width and height are not 0, the custom resolution will be used. Default value: 0. Note: this field may return null, indicating that no valid values can be obtained.
	// Maximum value of the height (or short side) of a video stream in px. Value range: `0` and `[128, 4096]`. If both `width` and `height` are `0`, the resolution will be the same as that of the source video; If `width` is `0`, but `height` is not `0`, `width` will be proportionally scaled; If `width` is not `0`, but `height` is `0`, `height` will be proportionally scaled; If both `width` and `height` are not `0`, the custom resolution will be used. Default value: `0`. Note: this field may return null, indicating that no valid values can be obtained.
	// +kubebuilder:validation:Optional
	Height *float64 `json:"height,omitempty" tf:"height,omitempty"`

	// Whether the transcoding output still maintains HDR when the original video is HDR (High Dynamic Range). Value range:
	// Whether the transcoding output still maintains HDR when the original video is HDR (High Dynamic Range). Value range:
	// - ON: if the original file is HDR, the transcoding output remains HDR;, otherwise the transcoding output is SDR (Standard Dynamic Range);
	// - OFF: regardless of whether the original file is HDR or SDR, the transcoding output is SDR;
	// Default value: OFF.
	// +kubebuilder:validation:Optional
	PreserveHdrSwitch *string `json:"preserveHdrSwitch,omitempty" tf:"preserve_hdr_switch,omitempty"`

	// Resolution adaption. Valid values: true,false. true: enabled. In this case, width represents the long side of a video, while height the short side; false: disabled. In this case, width represents the width of a video, while height the height. Default value: true. Note: this field may return null, indicating that no valid values can be obtained.
	// Resolution adaption. Valid values: `true`,`false`. `true`: enabled. In this case, `width` represents the long side of a video, while `height` the short side; `false`: disabled. In this case, `width` represents the width of a video, while `height` the height. Default value: `true`. Note: this field may return null, indicating that no valid values can be obtained.
	// +kubebuilder:validation:Optional
	ResolutionAdaptive *bool `json:"resolutionAdaptive,omitempty" tf:"resolution_adaptive,omitempty"`

	// Video constant bit rate control factor, value range is [1,51].
	// Note:
	// Video constant bit rate control factor, value range is [1,51].
	// Note:
	// - If this parameter is specified, the bitrate control method of CRF will be used for transcoding (the video bitrate will no longer take effect);
	// - This field is required when the video stream encoding format is H.266. The recommended value is 28;
	// - If there are no special requirements, it is not recommended to specify this parameter.
	// +kubebuilder:validation:Optional
	Vcrf *float64 `json:"vcrf,omitempty" tf:"vcrf,omitempty"`

	// Maximum value of the width (or long side) of a video stream in px. Value range: 0 and [128, 4096]. If both width and height are 0, the resolution will be the same as that of the source video; If width is 0, but height is not 0, width will be proportionally scaled; If width is not 0, but height is 0, height will be proportionally scaled; If both width and height are not 0, the custom resolution will be used. Default value: 0. Note: this field may return null, indicating that no valid values can be obtained.
	// Maximum value of the width (or long side) of a video stream in px. Value range: `0` and `[128, 4096]`. If both `width` and `height` are `0`, the resolution will be the same as that of the source video; If `width` is `0`, but `height` is not `0`, `width` will be proportionally scaled; If `width` is not `0`, but `height` is `0`, `height` will be proportionally scaled; If both `width` and `height` are not `0`, the custom resolution will be used. Default value: `0`. Note: this field may return null, indicating that no valid values can be obtained.
	// +kubebuilder:validation:Optional
	Width *float64 `json:"width,omitempty" tf:"width,omitempty"`
}

// AdaptiveDynamicStreamingTemplateSpec defines the desired state of AdaptiveDynamicStreamingTemplate
type AdaptiveDynamicStreamingTemplateSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     AdaptiveDynamicStreamingTemplateParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider AdaptiveDynamicStreamingTemplateInitParameters `json:"initProvider,omitempty"`
}

// AdaptiveDynamicStreamingTemplateStatus defines the observed state of AdaptiveDynamicStreamingTemplate.
type AdaptiveDynamicStreamingTemplateStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        AdaptiveDynamicStreamingTemplateObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// AdaptiveDynamicStreamingTemplate is the Schema for the AdaptiveDynamicStreamingTemplates API. Provide a resource to create a VOD adaptive dynamic streaming template.
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,tencentcloud}
type AdaptiveDynamicStreamingTemplate struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.format) || (has(self.initProvider) && has(self.initProvider.format))",message="spec.forProvider.format is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",message="spec.forProvider.name is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.streamInfo) || (has(self.initProvider) && has(self.initProvider.streamInfo))",message="spec.forProvider.streamInfo is a required parameter"
	Spec   AdaptiveDynamicStreamingTemplateSpec   `json:"spec"`
	Status AdaptiveDynamicStreamingTemplateStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// AdaptiveDynamicStreamingTemplateList contains a list of AdaptiveDynamicStreamingTemplates
type AdaptiveDynamicStreamingTemplateList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []AdaptiveDynamicStreamingTemplate `json:"items"`
}

// Repository type metadata.
var (
	AdaptiveDynamicStreamingTemplate_Kind             = "AdaptiveDynamicStreamingTemplate"
	AdaptiveDynamicStreamingTemplate_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: AdaptiveDynamicStreamingTemplate_Kind}.String()
	AdaptiveDynamicStreamingTemplate_KindAPIVersion   = AdaptiveDynamicStreamingTemplate_Kind + "." + CRDGroupVersion.String()
	AdaptiveDynamicStreamingTemplate_GroupVersionKind = CRDGroupVersion.WithKind(AdaptiveDynamicStreamingTemplate_Kind)
)

func init() {
	SchemeBuilder.Register(&AdaptiveDynamicStreamingTemplate{}, &AdaptiveDynamicStreamingTemplateList{})
}
